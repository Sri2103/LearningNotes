# DSA Playbook

## Universal Problem-Solving Steps

1. Restate problem
2. Identify limiting constraint
3. Classify into problem shape
4. Match shape → pattern
5. Identify core mechanism
6. Write state variables
7. Dry-run with smallest example
8. Write pseudocode
9. Code
10. Check time/space
11. Validate with edge cases
12. Extract lesson → flashcards

---

## Pattern Playbook (Summary)

### Sliding Window

When: substring/subarray, dynamic range  
Template: expand → violate → shrink

### Two Pointers

When: sorted → pair/triplet  
Template: move left/right intelligently

### Prefix Sum

When: subarray sum / difference  
Template: prefix difference tracking

### BFS/DFS

When: levels or graph connectivity  
Template: queue/stack with visited

### DP

When: overlapping subproblems  
Template: define state → transition → base case

### Backtracking

When: generate all possibilities  
Template: choose → explore → undo

### Heap

When: top-k, merging  
Template: push → pop smallest/largest

### Binary Search

When: sorted OR monotonic answer  
Template: search on index or answer
