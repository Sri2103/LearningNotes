# Algorithms & Math Playbook

## General Problem Solving Playbook

1. Understand constraints
2. Identify input type (array, graph, tree, math)
3. Try brute force mentally
4. Identify pattern (sliding window, DP, greedy, BFS/DFS)
5. Choose correct data structure
6. Optimize
7. Implement carefully
8. Check edge cases (empty, large, negative, duplicates)

---

## Time Complexity Playbook

- Always target O(n) or O(n log n)
- Check nested loops
- Check recursion depth
- Use amortized analysis

---

## Dynamic Programming Playbook

- define state
- define transitions
- memoize or tabulate
- check overlapping subproblems
- handle base cases

---

## Greedy Playbook

- find local optimal choice
- justify correctness with exchange argument
- verify with counterexamples

---

## Graph Playbook

- BFS → unweighted shortest path
- DFS → cycles, components
- Dijkstra → weighted shortest path
- DP on trees → subtrees
- Union-find → connectivity

---

## Math Playbook

- identify formula
- break into prime factors
- reduce modulo
- use combinatorics
- use recurrence or closed form
