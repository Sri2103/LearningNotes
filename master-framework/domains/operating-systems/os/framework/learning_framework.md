# Operating Systems Learning Framework

## 1. Why am I learning OS?

> To understand how processes, memory, CPU scheduling, synchronization, and filesystems work under the hood.

## 2. Subskills (Decomposition)

- Processes & threads
- Scheduling
- CPU mechanisms
- Memory management
- Virtual memory & paging
- Synchronization
- Filesystems
- IO subsystem
- OS architecture
- Kernel concepts
- System calls

## 3. Knowledge Map

Fundamentals → processes, scheduling  
Intermediate → paging, threads, deadlocks  
Advanced → kernel internals, drivers, IO stack

## 4. Core Resources

Books:

- Operating Systems: Three Easy Pieces (OSTEP)
- Modern Operating Systems – Tanenbaum
- Linux Kernel Development

## 5. Learning Method

Read → visualize → run experiments → write code → reflect

## 6. Practice Plan

Daily: concepts  
Weekly: small OS labs  
Monthly: deeper OS modules

## 7. OS Playbook

1. Identify OS subsystem (CPU, memory, disk, file, process)
2. Break into primitives (thread, lock, frame, inode)
3. Evaluate algorithm involved (LRU, RR, FIFO, MLFQ)
4. Predict performance behavior
5. Validate with experiment

## 8. Frequent mistakes

- Confusing process vs thread
- Misunderstanding deadlock
- Ignoring context switch cost
- Misinterpreting virtual memory
